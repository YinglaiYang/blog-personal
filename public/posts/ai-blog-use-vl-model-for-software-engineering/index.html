<!doctype html><html class="dark light"><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Accelerated Software Engineering: Hand draw State Diagrams and get PlantUML code.
        
    </title><meta content="Accelerated Software Engineering: Hand draw State Diagrams and get PlantUML code." property=og:title><meta content="Use Vision-Language Models to turn drawings into machine-readable UML." property=og:description><meta content="Use Vision-Language Models to turn drawings into machine-readable UML." name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://yangminded.com/fonts.css rel=stylesheet><link href=https://yangminded.com/atom.xml rel=alternate title=yangminded type=application/atom+xml><link href=https://yangminded.com/theme/light.css rel=stylesheet><link href=https://yangminded.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://yangminded.com/>yangminded</a><div class=socials><a class=social href=https://twitter.com/yangminded rel=me> <img alt=twitter src=/social_icons/twitter.svg> </a><a class=social href=https://github.com/yinglaiyang rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a><a href=/about style=margin-left:.7em>/about</a></nav></header><main><article><div class=title><div class=page-header>Accelerated Software Engineering: Hand draw State Diagrams and get PlantUML code.<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-02-23</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#introduction-expand-ai-copilots-beyond-coding>Introduction - Expand AI Copilots Beyond Coding</a><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#example-use-case-state-diagrams>Example Use Case - State Diagrams</a> <ul><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#draft-on-paper-transfer-to-code-using-vl-models>Draft on Paper, Transfer To Code Using VL-Models</a><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#using-qvq-72b-preview>Using QVQ-72B-Preview</a></li><ul><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#first-attempt-of-getting-a-plantuml-for-my-state-diagram>First attempt of getting a PlantUML for my state diagram</a><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#second-try-with-additional-context>Second try with additional context</a><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#fixing-the-mess>Fixing the "mess"</a></ul></ul><li><a href=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/#verdict>Verdict</a></ul><section class=body><h1 id=introduction-expand-ai-copilots-beyond-coding>Introduction - Expand AI Copilots Beyond Coding</h1><p>By now, everyone has heard about using LLMs for coding. You can just use a tool like plain VS Code with Github Copilot, Cursor, Windsurf or even just use ChatGPT or Claude and copy-paste code.<p>But this only covers the part of writing code.<p>If we look further into software development workflows, it generally involves more than just pushing out code.<ol><li><p>You have phases where you try to understand what has to be achieved. This can be done using <strong>formalized requirements</strong> or <strong>user-stories</strong>.</p> <ul><li>They make sure that you really understand what should be done, by forcing you and the stakeholders to communicate and align.<li>Requirements and user-stories also make it easier to onboard others into the development effort - since it will be much easier for them to understand what shall be achieved.</ul><li><p>Then you move on to design the "blueprint" of the software which include methods like <strong>state diagrams</strong><sup class=footnote-reference><a href=#1>1</a></sup>, <strong>sequence diagrams</strong> or <strong>class diagrams</strong>.</p> <ul><li>These make it easier for you to understand if the software can achieve all of the requirements.<li>They also allow you to find out if there are some edge-cases you might not have considered before.<li>Finally, again, such diagrams make it much easier to onboard others into the development effort.</ul><li><p>Finally, you need formalized testing like <strong>unit-tests</strong>. These are procedures that make sure that your code at least fulfills the intentions captured by the tests. In the long run, executing a full set of formalized tests will make sure that any code change you do, at least does not break previous functionalities.</p></ol><p><strong>What does it all mean in terms of using LLMs in the workflow?</strong> Does it mean the usage of LLMs will be reduced to toy projects that cannot scale to large complex software?<p><strong>I believe that AI-Copilots both benefits from all of the mentioned practices, and make it easier to create the artifacts from these practices!</strong><h1 id=example-use-case-state-diagrams>Example Use Case - State Diagrams</h1><p><em>Original date of experiment: 07.01.2025</em><h2 id=draft-on-paper-transfer-to-code-using-vl-models>Draft on Paper, Transfer To Code Using VL-Models</h2><p>State diagrams are something inherently visual. You could use drawing tools like Figma, Mural or Microsoft Visio to create visual state diagrams. While allowing you to work quickly and create state diagrams in an easy way, this has some disadvantages. For example version control is difficult. Also in many cases you would be locked into certain tools.<p>There is an alternative, which is widely used in some places: PlantUML<sup class=footnote-reference><a href=#2>2</a></sup><p>It is "UML-diagrams-as-code", which is perfect for pairing it with LLMs.<p>There is one pain point though. From my own experience, it is cumbersome to write PlantUML. It takes a lot of time, and is also prone to mistakes. Just small mistakes will lead to the whole diagram not rendering correctly!<p>It is much easier for me to draw a state diagram by hand.<p>How then to transfer the state diagram on paper to the computer?<p><strong>Vision-Language Models</strong> come to the rescue.<p>These are a type of LLMs that are extended to parse and understand images.<p>Below you can find my experiment in accelerating the creation of state diagrams.<h2 id=using-qvq-72b-preview>Using QVQ-72B-Preview</h2><p>I had an actual recent state diagram that I wanted to draft up for a private project ("AI Hangman" - more about it in later posts).<p>This is the scan using my smartphone of the state diagram that I drew up in my notebook: <img alt="Hand Drawn State Diagram" src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/AI-Hangman_state-diagram-handdrawn.jpg><p>I chose Alibaba Qwen's QVQ-72B-Preview model because it is a capable and open source model.<p>You can find their chat interface here: <a href=https://chat.qwenlm.ai>https://chat.qwenlm.ai</a><p>If you do not wish to create an account with Qwen, you can also find their models on Huggingface: <a href=https://huggingface.co/Qwen/QVQ-72B-Preview>https://huggingface.co/Qwen/QVQ-72B-Preview</a><h3 id=first-attempt-of-getting-a-plantuml-for-my-state-diagram>First attempt of getting a PlantUML for my state diagram</h3><h4 id=prompt>Prompt</h4><p>Here is the first attempt with the prompt:<blockquote><p>Please generate the PlantUML description for the state diagram that is drawn in this picture.</blockquote><p><img alt="Prompting QVQ first attempt" src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/screenshot_1.png><h4 id=answer>Answer</h4><details><summary>Read the full answer from QVQ:</summary> <blockquote><p>So I've got this hand-drawn flowchart, and I need to convert it into a PlantUML state diagram. I'm not super familiar with PlantUML syntax, but I'll try to figure it out step by step.<p>First, I need to understand the flow of the program from the diagram. It starts with "Initialize Settings," and then there's a decision point: "is AiGuessing?" Depending on whether it's true or false, it goes down different paths.<p>If "is AiGuessing?" is true, it goes to "Player Gives Word," and then checks if the word is in the dictionary. If not, it loops back to "Player Gives Word." If it is in the dictionary, it moves to "Watch Ai Play," and then checks if the game is finished. If not, it loops back to "Watch Ai Play"; if yes, it ends.<p>If "is AiGuessing?" is false, it goes to "Wait For Ai Word," then checks if the word is in the dictionary. If not, it loops back to "Wait For Ai Word." If yes, it moves to "Guess," then checks if the game is finished. If not, it loops back to "Guess"; if yes, it ends.<p>Alright, so in terms of states, I have:<ol><li>Initialize Settings<li>Player Gives Word<li>Wait For Ai Word<li>Watch Ai Play<li>Guess</ol><p>And decision points:<ul><li>is AiGuessing?<li>isWordInDictionary? (for both player and AI)<li>isGameFinished? (for both paths)</ul><p>In PlantUML, states are usually represented with rounded rectangles, and decisions are diamonds with questions inside. Arrows show the flow between these elements.<p>I think I need to use the state keyword for states and if for decisions. Let me start writing the PlantUML code. I'll begin with the initial state: state "Initialize Settings" as s1<p>Then, there's a decision: "is AiGuessing?" I can represent this with an if statement. From there, if "is AiGuessing?" is true, it goes to "Player Gives Word," otherwise to "Wait For Ai Word."<p>So: <code>if (is AiGuessing?) then (true) state "Player Gives Word" as s2 else (false) state "Wait For Ai Word" as s3 endif</code><p>Now, for "Player Gives Word," there's a check: "isWordInDictionary?" If no, loop back to "Player Gives Word"; if yes, go to "Watch Ai Play."<p>Similarly, for "Wait For Ai Word," there's the same check: "isWordInDictionary?" If no, loop back; if yes, go to "Guess."<p>Then, from "Watch Ai Play," check "isGameFinished?" If no, loop back; if yes, end.<p>From "Guess," check "isGameFinished?" If no, loop back; if yes, end.<p>Also, there's a start and end point. I need to make sure the flow starts from "Initialize Settings" and ends properly.<p>Let me try to sketch this out. Start -> s1: Initialize Settings if (is AiGuessing?) then (true) -> s2: Player Gives Word while (!isWordInDictionary?) -> s2: Player Gives Word end while -> s4: Watch Ai Play while (!isGameFinished?) -> s4: Watch Ai Play end while else (false) -> s3: Wait For Ai Word while (!isWordInDictionary?) -> s3: Wait For Ai Word end while -> s5: Guess while (!isGameFinished?) -> s5: Guess end while endif End<p>I think this captures the flow. Now, to translate this into PlantUML syntax. I'll use the state keyword for states, if for decisions, and while for loops.<p>Here's my attempt:<pre class=language-plantuml data-lang=plantuml style=background:#0f1419;color:#bfbab0><code class=language-plantuml data-lang=plantuml><span>@startuml
</span><span>state "Initialize Settings" as s1
</span><span>if (is AiGuessing?) then (true)
</span><span>state "Player Gives Word" as s2
</span><span>while (!isWordInDictionary?)
</span><span>state "Player Gives Word" as s2
</span><span>end while
</span><span>state "Watch Ai Play" as s4
</span><span>while (!isGameFinished?)
</span><span>state "Watch Ai Play" as s4
</span><span>end while
</span><span>else
</span><span>state "Wait For Ai Word" as s3
</span><span>while (!isWordInDictionary?)
</span><span>state "Wait For Ai Word" as s3
</span><span>end while
</span><span>state "Guess" as s5
</span><span>while (!isGameFinished?)
</span><span>state "Guess" as s5
</span><span>end while
</span><span>endif
</span><span>stop
</span><span>@enduml
</span></code></pre><p>I think this should work. I might need to adjust the syntax a bit, but this is a good starting point. Wait, in PlantUML, the while loop is usually represented inside a state, but I'm not sure if it's exactly like this. Maybe I should use loop instead.<p>Let me check the PlantUML documentation. Okay, according to the docs, you can use loop inside a state to represent loops. So, perhaps it's better to use loop instead of while. Also, in PlantUML, the if statement should be followed by then and else, and ended with endif.<p>I think my previous syntax is close, but maybe I need to adjust the loop representation. Let me try again:<pre class=language-plantuml data-lang=plantuml style=background:#0f1419;color:#bfbab0><code class=language-plantuml data-lang=plantuml><span>@startuml
</span><span>state "Initialize Settings" as s1
</span><span>if (is AiGuessing?) then (true)
</span><span>state "Player Gives Word" as s2
</span><span>loop (!isWordInDictionary?)
</span><span>state "Player Gives Word" as s2
</span><span>end loop
</span><span>state "Watch Ai Play" as s4
</span><span>loop (!isGameFinished?)
</span><span>state "Watch Ai Play" as s4 
</span><span>end loop 
</span><span>else 
</span><span>state "Wait For Ai Word" as s3
</span><span>loop (!isWordInDictionary?)
</span><span>state "Wait For Ai Word" as s3
</span><span>end loop 
</span><span>state "Guess" as s5 
</span><span>end loop 
</span><span>endif 
</span><span>stop 
</span><span>@enduml
</span></code></pre></blockquote></details><h4 id=compiled-result>Compiled Result</h4><p><img alt="The result as compiled in VS Code using the PlantUML extension." src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/screenshot_2.png><p>Hmmm. Does not look very good. So what is wrong?<p>I notice that it does not draw arrows between the states, but rather implements if/else clauses and loops. I will try to correct it by giving QVQ this information.<h3 id=second-try-with-additional-context>Second try with additional context</h3><h4 id=prompt-1>Prompt</h4><blockquote><p>Please generate the PlantUML description for the state diagram that is drawn in this picture.<p>There are only one-directional transitions going between states and sometimes conditionals.<p>There are some conditionals that result in the outgoing state being revisited - meaning that the state transitions into itself under certain conditions.</blockquote><h4 id=answer-1>Answer</h4><blockquote><pre class=language-plantuml data-lang=plantuml style=background:#0f1419;color:#bfbab0><code class=language-plantuml data-lang=plantuml><span>@startuml
</span><span>state "Initialize Settings" as IS
</span><span>state "Player Gives Word" as PW
</span><span>state "Wait For Ai Word" as WAIW
</span><span>state "Watch Ai Play" as WAP
</span><span>state "Guess" as G
</span><span>final state "Game Finished" as GF
</span><span>IS --> PW : is AiGuessing? = true
</span><span>IS --> WAIW : is AiGuessing? = false
</span><span>PW --> WAP : isWordInDictionary? = yes
</span><span>PW --> PW : isWordInDictionary? = no
</span><span>WAIW --> G : isWordInDictionary? = yes
</span><span>WAIW --> WAIW : isWordInDictionary? = no
</span><span>WAP --> WAP : isGameFinished? = no
</span><span>WAP --> GF : isGameFinished? = yes
</span><span>G --> G : isGameFinished? = no
</span><span>G --> GF : isGameFinished? = yes
</span><span>@enduml
</span></code></pre></blockquote><h4 id=compiled-result-1>Compiled Result</h4><p><img alt="The new result. It has a bug message." src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/screenshot_3.png> As you can see, there are still bugs in it.<h3 id=fixing-the-mess>Fixing the "mess"</h3><p>I try to get Github Copilot to fix it, to test how capable that is. It does not find the syntax error given by the PlantUML Preview. <img alt="Copilot fails to find the issue." src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/screenshot_4.png><p>Eventually, I did a small manual fix: I removed the „final“ in line 7. Now it gives an actual state diagram. <img alt="Small bug that was manually fixed to give a parseable PlantUML." src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/screenshot_5.png><p>If you remember the original drawing of the state diagram, the idea is that after each finished game of Hangman, the program loops back to the settings so that you can play a new game. But the state diagram that Qwen created ends in a new state named "Game Finished".<h1 id=verdict>Verdict</h1><ul><li><strong>There is a lot of potential</strong> for using multimodal models to transfer visual UML diagrams into computer readable description files.<li><strong>General multimodal model like Qwen QVQ already show a lot of promise.</strong> Despite PlantUML being a niche description language! This means for PlantUML there might not even be a need for fine-tuning.<li><strong>But it does not quite work yet. I hypothesize the image understanding part needs to be improved the most</strong> for this particular use-case. The language part that generates the PlantUML code is almost there.</ul><p>What might be difficult for the image understanding part:<ol><li><p>It needs help to understand with what vocabulary to parse and describe a state diagram.</p> <ul><li>The first PlantUML that was generated tried to introduce "loops". The transitions that keep the same state as the next state do look like 🔄.<li>This is a hint that the image understanding of QVQ was trying to parse the image with more general vocabulary like "loop".<li>This would also explain why QVQ became a lot better when it was told that the image only contains one-directional transitions going between states, which focuses the vocabulary of the image understanding into "transitions" and "states".</ul><li><p>It seems to have difficulties in following arrows over long distances.</p> <ul><li>See the purple boxes in the first image below. The outgoing and ingoing states are relatively far away from each other. Closeness in position might correlate in a way with how much the image understanding will create relationships between two sections in the image.<li>See the red marking in the first image below. The arrow on the left is a bit broken-up. This is an artifact from the scanning process with my phone. However it is unlikely to be a big factor for the failing, since the right arrow is complete. Still QVQ was not able to follow it.<li>See the green markings in the second image below. The arrow markings which point out that the lines are arrows, not just any line, are far away from the outgoing state that they are connected to. Maybe it would make it easier for QVQ to tell that it needs to follow the whole lines to connect with something by adding an arrow marking close to the decision behind the outgoing state.</ul></ol><p>I will try out some experiments in the future to see if I can support the hypotheses here.<div style=text-align:center><p><img alt="Exhibit 1" src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/annotated_1.jpeg> <img alt="Exhibit 2" src=https://yangminded.com/posts/ai-blog-use-vl-model-for-software-engineering/annotated_2.jpeg></div><hr><p><strong>Footnotes</strong><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>https://en.wikipedia.org/wiki/State_diagram</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>https://plantuml.com/de/</div></section></article></main></div><script src=/js/main.js></script>